import TelegramBot from 'node-telegram-bot-api';
import connectDB from './mongodb';
import Client from '../models/Client';
import Message from '../models/Message';
import Promo from '../models/Promo';

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

let bot;
if (BOT_TOKEN) {
  console.log('ü§ñ Initializing Telegram bot with token:', BOT_TOKEN.substring(0, 10) + '...');
  bot = new TelegramBot(BOT_TOKEN);
} else {
  console.error('‚ùå No TELEGRAM_BOT_TOKEN found in environment variables');
}

export async function handleTelegramUpdate(update) {
  console.log('ü§ñ Handling Telegram update...');
  
  try {
    await connectDB();
    console.log('‚úÖ Database connected');
  } catch (error) {
    console.error('‚ùå Database connection failed:', error);
    throw error;
  }
  
  const message = update.message;
  if (!message) {
    console.log('‚ö†Ô∏è No message in update');
    return;
  }
  
  console.log('üìù Processing message from:', message.from.first_name);

  try {
    // Save or update client
    const clientData = {
      telegramId: message.from.id.toString(),
      firstName: message.from.first_name,
      lastName: message.from.last_name || '',
      username: message.from.username || '',
      language: message.from.language_code || 'en'
    };

    let client = await Client.findOne({ telegramId: clientData.telegramId });
    if (!client) {
      client = new Client(clientData);
      await client.save();
    } else {
      // Update client info if changed
      Object.assign(client, clientData);
      await client.save();
    }

    // Save message
    const messageData = {
      messageId: message.message_id.toString(),
      clientId: client._id,
      type: getMessageType(message),
      content: getMessageContent(message),
      direction: 'incoming',
      timestamp: new Date(message.date * 1000)
    };

    const newMessage = new Message(messageData);
    await newMessage.save();

    // Handle bot commands and responses
    await handleBotLogic(message, client);

  } catch (error) {
    console.error('Error handling Telegram update:', error);
  }
}

function getMessageType(message) {
  if (message.text && message.text.startsWith('/')) return 'command';
  if (message.text) return 'text';
  if (message.photo) return 'photo';
  if (message.sticker) return 'sticker';
  if (message.document) return 'document';
  if (message.voice) return 'voice';
  if (message.video) return 'video';
  if (message.location) return 'location';
  if (message.contact) return 'contact';
  return 'text';
}

function getMessageContent(message) {
  if (message.text) return message.text;
  if (message.photo) return 'Photo';
  if (message.sticker) return 'Sticker';
  if (message.document) return message.document.file_name || 'Document';
  if (message.voice) return 'Voice message';
  if (message.video) return 'Video';
  if (message.location) return `Location: ${message.location.latitude}, ${message.location.longitude}`;
  if (message.contact) return `Contact: ${message.contact.first_name} ${message.contact.phone_number}`;
  return 'Unknown message type';
}

async function handleBotLogic(message, client) {
  const text = message.text;
  const chatId = message.chat.id;

  try {
    if (text === '/start') {
      await sendMessage(chatId, `–ü—Ä–∏–≤–µ—Ç, ${client.firstName}! üëã\n\n–Ø –±–æ—Ç –¥–ª—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤. –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –∫–æ–¥ –ø—Ä–æ–º–æ, –∏ —è –ø—Ä–æ–≤–µ—Ä—é –µ–≥–æ –¥–ª—è —Ç–µ–±—è!`);
    } else if (text === '/help') {
      await sendMessage(chatId, `–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n\n/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n\n–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ –ø—Ä–æ–º–æ–∫–æ–¥, –∏ —è –ø—Ä–æ–≤–µ—Ä—é –µ–≥–æ!`);
    } else if (text && text.startsWith('/')) {
      await sendMessage(chatId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.');
    } else if (text) {
      // Check if message is a promo code
      await checkPromoCode(chatId, text.toUpperCase(), client);
    }
  } catch (error) {
    console.error('Error in bot logic:', error);
    await sendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
}

async function checkPromoCode(chatId, code, client) {
  try {
    const promo = await Promo.findOne({ 
      code: code, 
      isActive: true,
      expiresAt: { $gt: new Date() }
    });

    let responseText;
    if (promo) {
      responseText = `‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –Ω–∞–π–¥–µ–Ω!\n\n` +
        `üè∑Ô∏è –ö–æ–¥: ${promo.code}\n` +
        `üí∞ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: ${promo.minPrice}‚ÇΩ\n` +
        `üè™ –ú–∞–≥–∞–∑–∏–Ω: ${promo.store}\n` +
        `üìç –õ–æ–∫–∞—Ü–∏–∏: ${promo.locations.join(', ')}\n` +
        `‚è∞ –î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: ${promo.expiresAt.toLocaleDateString('ru-RU')}`;
    } else {
      responseText = `‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ "${code}" –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏—Å—Ç–µ–∫ —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è.`;
    }

    await sendMessage(chatId, responseText);
  } catch (error) {
    console.error('Error checking promo code:', error);
    await sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
}

export async function sendMessage(chatId, text, options = {}) {
  if (!bot) {
    console.error('Bot not initialized - missing BOT_TOKEN');
    return;
  }

  try {
    const sentMessage = await bot.sendMessage(chatId, text, options);
    
    // Save outgoing message to database
    await connectDB();
    const client = await Client.findOne({ telegramId: chatId.toString() });
    
    if (client) {
      const messageData = {
        messageId: sentMessage.message_id.toString(),
        clientId: client._id,
        type: 'text',
        content: text,
        direction: 'outgoing',
        timestamp: new Date(sentMessage.date * 1000)
      };

      const newMessage = new Message(messageData);
      await newMessage.save();
    }

    return sentMessage;
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
}

export { bot };
